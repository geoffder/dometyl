<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>walkthrough (dometyl.walkthrough)</title><meta charset="utf-8"/><link rel="stylesheet" href="../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="index.html">Up</a> â€“ <a href="index.html">dometyl</a> &#x00BB; walkthrough</nav><header class="odoc-preamble"><h1 id="basic-usage-walkthrough"><a href="#basic-usage-walkthrough" class="anchor"></a>Basic Usage Walkthrough</h1><pre class="language-ocaml"><code>open OCADml
open OSCADml
open Dometyl</code></pre><p>First, lets make our keyhole early as we'll need it for viewing intermediary results in this walkthrough. Here we define an mx keyhole with bezier roundovers on the sides, with a minimum <code>clearance</code> of <code>2.</code> from the table (to give space for wiring etc below the switch plate).</p><pre class="language-ocaml"><code>let keyhole =
  Mx.make_hole
    ~clearance:2.
    ~corner:(Path3.Round.bez (`Cut 0.5)) (* roundover cut in from corner *)
    ~fn:16 (* number of points in the bezier rounded corners *)
    ()</code></pre><p>We can write our keyhole to an OpenSCAD script by first obtaining the <code>Scad.t</code>, then using <code>OCADml.Scad.to_file</code>. Doing this can be a quick way to get a better look at individual pieces of our models, so we'll be doing it at steps throughout this guide (though doing so is not required for the usual keyboard generation config workflow).</p><pre class="language-ocaml"><code>let () = Scad.to_file &quot;keyhole.scad&quot; @@ Key.to_scad keyhole</code></pre>
<p style="text-align:center;">
<img src="_assets/keyhole.png" style="width:150mm;"/>
</p> <p>Next, we'll describe how we would like our keyholes to be arranged into columns to form the switch plate. The <a href="Dometyl/Plate/Lookups/index.html#val-body" title="Dometyl.Plate.Lookups.body"><code>Plate.Lookups.body</code></a> constructor takes a set of lookup functions from column indices to values governing the construction and placement of each of the columns independently.</p><p><code>~offset</code> allows us to set the xyz offset of our columns, particular mind paid to y and z stagger, which helps adjust column placement to the lenghts of our fingers:</p><pre class="language-ocaml"><code>let offset = function
  | 2 -&gt; v3 0. 3.5 (-5.) (* middle *)
  | 3 -&gt; v3 1. (-2.5) 0.5 (* ring *)
  | i when i &gt;= 4 -&gt; v3 0.5 (-18.) 8.5 (* pinky *)
  | 0 -&gt; v3 (-2.5) 0. 5. (* inner index *)
  | _ -&gt; v3 0. 0. 0. (* home index *)</code></pre><p>We use <code>~curve</code> to define a <a href="Dometyl/Curvature/index.html#type-t" title="Dometyl.Curvature.t"><code>Curvature.t</code></a> with which our keyholes will be distributed for each column. For our main switchplate columns, we'll usually be distributing keys to points at increasing angles along a circle of a given <code>~radius</code> drawn on the yz plane. To do this we can use <a href="Dometyl/Curvature/index.html#val-well" title="Dometyl.Curvature.well"><code>Curvature.well</code></a>, and give the result to the <code>~well</code> parameter of the <a href="Dometyl/Curvature/index.html#val-curve" title="Dometyl.Curvature.curve"><code>Curvature.curve</code></a> constructor.</p><p>To angle the inner index column towards the home index column (with a y-axis rotation), bringing the tops of the keys closer together, we can use the <code>~tilt</code> parameter of <a href="Dometyl/Curvature/index.html#val-well" title="Dometyl.Curvature.well"><code>Curvature.well</code></a>.</p><pre class="language-ocaml"><code>let curve = function
  | i when i &gt;= 3 -&gt;
    (* ring and pinky *)
    Curvature.(curve ~well:(well ~radius:37. (Float.pi /. 4.25)) ())
  | i when i = 0 -&gt;
    (* inner index *)
    Curvature.(
      curve ~well:(well ~tilt:(Float.pi /. 7.5) ~radius:46. (Float.pi /. 5.95)) ())
  | _ -&gt; Curvature.(curve ~well:(well ~radius:46.5 (Float.pi /. 6.1)) ())</code></pre><p>To get an idea of how these curvature descriptions will go on to be used, we can try out <a href="Dometyl/Curvature/index.html#val-apply" title="Dometyl.Curvature.apply"><code>Curvature.apply</code></a> directly for a 3 row column using the tilted inner index curvature (<code>curve 0</code>) defined above.</p><pre class="language-ocaml"><code>let () =
  List.init 3 (fun row -&gt;
      Key.to_scad @@ Curvature.apply ~centre_idx:1. (curve 0) row keyhole )
  |&gt; Scad.union
  |&gt; Scad.to_file &quot;column_keys.scad&quot;</code></pre>
<p style="text-align:center;">
<img src="_assets/column_keys.png" style="width:150mm;"/>
</p> <p>If the value of <code>~splay</code> is non-zero for a particular column, it will be z-axis rotated about its centre-point (see <code>~centre</code> below). Some find that angling out the ring and pinky finger columns like this better matches the path that that those fingers take when they are extended. As the columns are pushed further out as a result, it can be important to try and shave off as much x spacing between the columns as possible to avoid strain from over splaying the fingers.</p><pre class="language-ocaml"><code>let splay = function
  | i when i = 3 -&gt; Float.pi /. -25. (* ring *)
  | i when i &gt;= 4 -&gt; Float.pi /. -11. (* pinky *)
  | _ -&gt; 0. (* none for the rest *)</code></pre><p>These are the default values for the <code>rows</code>, <code>swing</code>, and <code>centre</code> parameters to <a href="Dometyl/Plate/Lookups/index.html#val-body" title="Dometyl.Plate.Lookups.body"><code>Plate.Lookups.body</code></a>, but we'll include them here as an example of defining them.</p><ul><li><code>rows</code> sets how many rows each column should have</li><li><code>swing</code> indicates that the column should be <b>swung</b> with a y-axis rotation. This can be thought of like the <b>row curvature</b> of traditional dactyls, except applied to columns independently, rather than being a means of distributing the columns horizontally.</li><li><code>centre</code> sets a row &quot;index&quot; to serve as the centre of curvature for the column. As this is a float, rather than an integer, it can lie between rows, rather than being constrained to them.</li></ul><pre class="language-ocaml"><code>let rows _ = 3
let swing _ = 0.
let centre _ = 1.</code></pre><p>Finally, we'll construct our <code>body_lookups</code>, which we'll be handing to <a href="Dometyl/Plate/index.html#val-make" title="Dometyl.Plate.make"><code>Plate.make</code></a>.</p><pre class="language-ocaml"><code>let body_lookups = Plate.Lookups.body ~offset ~curve ~splay ~swing ~rows ~centre ()</code></pre><p>For our thumb cluster, we'll just provide <code>~curve</code>, and leave the rest as default. Note that we are making use of <a href="Dometyl/Curvature/index.html#val-fan" title="Dometyl.Curvature.fan"><code>Curvature.fan</code></a>, which places keys along a circle laying on the xy plane, in conjunction with <code>well</code> this time.</p><pre class="language-ocaml"><code>let thumb_lookups =
  let curve _ =
    Curvature.(
      curve
        ~fan:(fan ~radius:70. ~tilt:(Float.pi /. 48.) (Float.pi /. 9.))
        ~well:(well ~radius:47. (Float.pi /. 7.5))
        ())
  in
  Plate.Lookups.thumb ~curve ()</code></pre><p>Now with our <code>body_lookups</code> and <code>thumb_lookups</code> complete, we'll finish off our plate specification with some of the more tersely defined parameters of <a href="Dometyl/Plate/index.html#val-make" title="Dometyl.Plate.make"><code>Plate.make</code></a>.</p><pre class="language-ocaml"><code>let plate_builder =
  Plate.make
    ~n_body_cols:5 (* number of columns *)
    ~body_lookups
    ~thumb_lookups
    ~thumb_offset:(v3 (-13.) (-41.) 10.) (* translation *)
    ~thumb_angle:Float.(v3 (pi /. 40.) (pi /. -14.) (pi /. 24.)) (* rotation *)
    ~caps:Caps.Matty3.row (* strictly for visualizing *)
    ~thumb_caps:Caps.MT3.(fun i -&gt; if i = 1 then space_1_25u else space_1u)</code></pre><p>This <code>plate_builder</code> is left as a closure, since our <a href="Dometyl/Key/index.html#type-t" title="Dometyl.Key.t"><code>Key.t</code></a> will be passed to it within the <a href="Dometyl/Case/index.html#val-make" title="Dometyl.Case.make"><code>Case.make</code></a> constructor, but we can take a peak at our efforts so far by applying it ourselves.</p><pre class="language-ocaml"><code>let switch_plate = plate_builder keyhole
let () = Scad.to_file &quot;switch_plate.scad&quot; @@ Plate.to_scad switch_plate</code></pre>
<p style="text-align:center;">
<img src="_assets/switch_plate.png" style="width:150mm;"/>
</p> <p>Note how the columns have not been connected in any way yet. We'll be adding some bridging reinforcements later when we build the rest of the case.</p><p>The next major part of our keyboard to design are the walls projecting from the keys of our switch plate to the xy-plane. The <a href="Dometyl/Walls/index.html#val-auto_body" title="Dometyl.Walls.auto_body"><code>Walls.auto_body</code></a> and <a href="Dometyl/Walls/index.html#val-auto_thumb" title="Dometyl.Walls.auto_thumb"><code>Walls.auto_thumb</code></a> helpers are provided as a means to do so automatically with defaults that should be (at least close to) adequate for typical skeletal cases. Note that our <code>body_builder</code> and <code>thumb_builder</code> functions below take a <code>Plate.t</code> as a parameter, as we'll be passing our <code>wall_builder</code> along to <a href="Dometyl/Case/index.html#val-make" title="Dometyl.Case.make"><code>Case.make</code></a> much like <code>plate_builder</code>.</p><pre class="language-ocaml"><code>let body_builder plate =
  Walls.auto_body
    ~d1:(`Abs 14.) (* distance outward from key face to project before descent *)
    ~d2:10. (* distance away from key that the wall should hit the xy plane *)
    ~n_steps:(`PerZ 0.5) (* resolution of walls scaling relative to z height *)
    ~scale:(v2 0.8 0.9) (* scale wall by these factors in width and thickness *)
    ~scale_ez:(v2 0.42 1., v2 1. 1.) (* bezier easing of the scaling *)
    plate</code></pre><p>In addition to the parameters we're defining in <code>body_builder</code> above, we'll also specify the <code>_lookup</code> parameters for <a href="Dometyl/Walls/index.html#val-auto_thumb" title="Dometyl.Walls.auto_thumb"><code>Walls.auto_thumb</code></a> that flag whether or not perimeter key faces at particular indices should have walls projected from them or not.</p><pre class="language-ocaml"><code>let thumb_builder plate =
  Walls.auto_thumb
    ~d1:(`Abs 14.)
    ~d2:8.
    ~n_steps:(`PerZ 0.5)
    ~north_lookup:(fun _ -&gt; false) (* no walls on the north side*)
    ~south_lookup:(fun i -&gt; i &lt;&gt; 1) (* no wall at position 1 in the south *)
    ~east_lookup:(fun _ -&gt; false) (* no walls on the east side *)
    ~west_lookup:(fun _ -&gt; true) (* include a wall each (just one) western face *)
    ~scale:(v2 0.8 0.9)
    ~scale_ez:(v2 0.42 1., v2 1. 1.)
    plate

let wall_builder plate =
  Walls.make ~body:(body_builder plate) ~thumb:(thumb_builder plate)</code></pre><p>We'll see the walls hooked up to the rest of the case later, so here they are without any pesky context to block the view.</p><pre class="language-ocaml"><code>let walls = wall_builder switch_plate
let () = Scad.to_file &quot;walls.scad&quot; (Walls.to_scad walls)</code></pre>
<p style="text-align:center;">
<img src="_assets/walls.png" style="width:150mm;"/>
</p> <p>So there are walls projecting our switch plate to the ground, but we still have to &quot;wire&quot; them up to create a complete perimeter base for our case. For that, we turn to the <a href="Dometyl/Connect/index.html" title="Dometyl.Connect"><code>Connect</code></a> module, which includes the helper (in the same spirit at the <code>auto_</code> functions in <a href="Dometyl/Walls/index.html" title="Dometyl.Walls"><code>Walls</code></a>) that we'll be using for this case: <a href="Dometyl/Connect/index.html#val-skeleton" title="Dometyl.Connect.skeleton"><code>Connect.skeleton</code></a>. The <code>skeleton</code> connection generator defaults to using filleted sweeps along splines running along the xy plane between neighbouring walls, with the option to specify that certain walls should instead have the gap fully closed off (see <code>close_thumb</code> and <code>_joins</code> parameters).</p><pre class="language-ocaml"><code>let base_connector =
  Connect.skeleton
    ~height:13. (* default spline connection height *)
    ~index_height:16. (* height of index column connections *)
    ~thumb_height:14. (* height of thumb cluster connections *)
    ~corner:(Path3.Round.bez (`Joint 2.)) (* top corner roundovers *)
    ~corner_fn:16 (* roundover resolution *)
    ~north_joins:(fun i -&gt; i &lt; 2) (* fully join walls until the middle finger *)
    ~south_joins:(fun _ -&gt; false)

let connections = base_connector walls
let () = Scad.to_file &quot;connections.scad&quot; (Connect.to_scad connections)</code></pre>
<p style="text-align:center;">
<img src="_assets/connections.png" style="width:150mm;"/>
</p> <p>As mentioned earlier when we made our plate, we'd like to add some structural support between our columns as well. For that we have the <code>~plate_welder</code> parameter of <a href="Dometyl/Case/index.html#val-make" title="Dometyl.Case.make"><code>Case.make</code></a> -- a function that takes a <a href="Dometyl/Plate/index.html#type-t" title="Dometyl.Plate.t"><code>Plate.t</code></a> as argument, and returns a <code>Scad.t</code> to add on to the plate when the case is built.</p><p>The <a href="Dometyl/Plate/index.html#val-skeleton_bridges" title="Dometyl.Plate.skeleton_bridges"><code>Plate.skeleton_bridges</code></a> helper roughly mimics the pattern seen on the <a href="https://github.com/Bastardkb/Skeletyl">BastardKB Skeletyl</a>, and will often be adequate for similar designs, but here we'll add in a little extra reinforcement by using <a href="Dometyl/Bridge/index.html#val-cols" title="Dometyl.Bridge.cols"><code>Bridge.cols</code></a> to seal up between the index and middle finger columns.</p><pre class="language-ocaml"><code>let plate_welder plate =
  Scad.union [ Plate.skeleton_bridges plate; Bridge.cols ~columns:plate.body 1 2 ]

let () =
  Scad.to_file &quot;plate_glue.scad&quot;
  @@ Scad.add (Plate.to_scad switch_plate) (plate_welder switch_plate)</code></pre>
<p style="text-align:center;">
<img src="_assets/plate_glue.png" style="width:150mm;"/>
</p> <p>For the splaytyl (which this guide is based on), the <a href="https://github.com/Bastardkb/Elite-C-holder">BastardKB Elite-C holder</a> is used to mount the MCU inside the case, so the <code>~ports_cutter</code> parameter of <a href="Dometyl/Case/index.html#val-make" title="Dometyl.Case.make"><code>Case.make</code></a> will be set accordingly. The basics of <a href="Dometyl/Ports/index.html#val-reversible_holder" title="Dometyl.Ports.reversible_holder"><code>Ports.reversible_holder</code></a> are the similar though. Initial placement of the additions/subtractions to the case that these functions provide is automated depending on the location of the index column walls, but it isn't perfect of course, so offset and rotation parameters are available to fudging things to get the fit right for your particular case.</p><pre class="language-ocaml"><code>let ports_cutter = BastardShield.(cutter ~x_off:0. ~y_off:0. (make ()))</code></pre><p>Finally, we're ready to build our case. As each of the values defined along the way have been named according to the <code>~keyword</code> parameters that <a href="Dometyl/Case/index.html#val-make" title="Dometyl.Case.make"><code>Case.make</code></a> takes, we can just apply them with <i>punning</i> at this stage. Since this example config uses plain Mx holes without hotswap, our model will be fully mirrorable, so no need to fuss with the <code>?right_hand</code> parameter to get each hand of our case. For examples of doing so, check out the example configs in the dometyl repo.</p><pre class="language-ocaml"><code>let case =
  Case.make
    ~eyelets:(Case.eyelets ~config:Eyelet.m4_config ())
    ~plate_builder
    ~plate_welder
    ~wall_builder
    ~base_connector
    ~ports_cutter
    keyhole

let () = Scad.to_file &quot;right_case.scad&quot; (Case.to_scad case)</code></pre>
<p style="text-align:center;">
<img src="_assets/right_case.png" style="width:150mm;"/>
</p> <p>Next, we can generate a base plate to go along with the case by using <a href="Dometyl/Bottom/index.html#val-make" title="Dometyl.Bottom.make"><code>Bottom.make</code></a>. The form and fastener placement is automatic based on the given case, but bumpon size and location can be adjusted depending on materials used, and peculiarities of the case that mean the default locations leave a bit to be desired.</p><p>Here, to specify bumpon locations, we give a list of column and row <a href="Dometyl/Idx/index.html#type-t" title="Dometyl.Idx.t"><code>Idx.t</code></a>s under which they will be roughly placed, along with relative coordinates (<code>(v2 0.5 0.5)</code> being directly under the centre of the keyhole) to offset by.</p><pre class="language-ocaml"><code>let bottom =
  let bump_locs =
    Bottom.
      [ thumb ~loc:(v2 0.5 0.2) Last First
      ; thumb ~loc:(v2 0.7 0.) Last Last
      ; body ~loc:(v2 0. 1.) First Last
      ; body ~loc:(v2 0.5 1.2) (Idx 3) Last
      ; body ~loc:(v2 0.9 0.8) Last Last
      ; body ~loc:(v2 0.8 0.) Last First
      ]
  in
  Bottom.make ~bump_locs case</code></pre><p>Let's take a look at it rotated around so that we can see the more interesting side.</p><pre class="language-ocaml"><code>let () =
  Scad.to_file &quot;right_base_plate.scad&quot; (Scad.zrot Float.pi @@ Scad.xrot Float.pi bottom)</code></pre>
<p style="text-align:center;">
<img src="_assets/right_base_plate.png" style="width:150mm;"/>
</p> <p>Tenting bases with bumpon feet can be similarly generated using the <a href="Dometyl/Tent/index.html" title="Dometyl.Tent"><code>Tent</code></a> module.</p><pre class="language-ocaml"><code>let whiffle_tent = Tent.make ~style:(Tent.prison ()) case
let () = Scad.to_file &quot;right_tent.scad&quot; whiffle_tent</code></pre>
<p style="text-align:center;">
<img src="_assets/right_tent.png" style="width:150mm;"/>
</p> </header><div class="odoc-content"></div></body></html>
